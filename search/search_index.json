{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Firefox Lockbox for Android documentation!", 
            "title": "Introduction"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nThank you for considering and taking the time to contribute!\n\n\nThe following are guidelines for contributing to this project.\n\n\nCode of Conduct\n\n\nThis repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the \nMozilla Community Participation Guidelines\n and \nDeveloper Etiquette Guidelines\n.\n\n\nHow to Get Started\n\n\nPlease refer to installation and build instructions in the \ndocumentation\n.\n\n\nLeakCanary\n\n\nWe use \nLeakCanary\n to monitor memory leaks in Debug builds of the Lockbox Android application. Please read the documentation and pay attention to warnings while debugging the application!\n\n\nHow to Report Bugs\n\n\nPlease open \na new issue in the GitHub repository\n with steps to reproduce the problem you're experiencing.\n\n\nBe sure to include as much information including screenshots, text output, and both your expected and actual results.\n\n\nIf you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com\n\n\nHow to Request Enhancements\n\n\nFirst, please refer to the applicable \nGitHub repository\n and search \nthe repository's GitHub issues\n to make sure your idea has not been (or is not still) considered.\n\n\nThen, please \ncreate a new issue in the GitHub repository\n describing your enhancement.\n\n\nBe sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile.\n\n\nPlease keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.\n\n\nHow to Contribute Code\n\n\nBefore you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of \ngood first issues\n and find something that sounds interesting.\n\n\nIf there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to \nfile an issue\n first.\n\n\nOnce you have a patch ready:\n\n\n\n\nMake sure all tests are passing and try to add tests for the code you've written.\n\n\nSubmit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "Thank you for considering and taking the time to contribute!  The following are guidelines for contributing to this project.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#code-of-conduct", 
            "text": "This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the  Mozilla Community Participation Guidelines  and  Developer Etiquette Guidelines .", 
            "title": "Code of Conduct"
        }, 
        {
            "location": "/contributing/#how-to-get-started", 
            "text": "Please refer to installation and build instructions in the  documentation .", 
            "title": "How to Get Started"
        }, 
        {
            "location": "/contributing/#leakcanary", 
            "text": "We use  LeakCanary  to monitor memory leaks in Debug builds of the Lockbox Android application. Please read the documentation and pay attention to warnings while debugging the application!", 
            "title": "LeakCanary"
        }, 
        {
            "location": "/contributing/#how-to-report-bugs", 
            "text": "Please open  a new issue in the GitHub repository  with steps to reproduce the problem you're experiencing.  Be sure to include as much information including screenshots, text output, and both your expected and actual results.  If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com", 
            "title": "How to Report Bugs"
        }, 
        {
            "location": "/contributing/#how-to-request-enhancements", 
            "text": "First, please refer to the applicable  GitHub repository  and search  the repository's GitHub issues  to make sure your idea has not been (or is not still) considered.  Then, please  create a new issue in the GitHub repository  describing your enhancement.  Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile.  Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.", 
            "title": "How to Request Enhancements"
        }, 
        {
            "location": "/contributing/#how-to-contribute-code", 
            "text": "Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of  good first issues  and find something that sounds interesting.  If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to  file an issue  first.  Once you have a patch ready:   Make sure all tests are passing and try to add tests for the code you've written.  Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.", 
            "title": "How to Contribute Code"
        }, 
        {
            "location": "/metrics/", 
            "text": "Firefox Lockbox for Android Metrics Plan\n\n\nLast Updated: October 8, 2018\n\n\n\n\n\n\n\nAnalysis\n\n\nCollection\n\n\nList of Proposed Events\n\n\nAdjust SDK\n\n\nReferences\n\n\n\n\n\n\n\nThis is the metrics collection plan for the Lockbox Android app. It documents all events that are planned to be collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found \nhere\n.\n\n\nAnalysis\n\n\nData collection is done solely for the purpose of product development, improvement and maintenance.\n\n\nWe will analyze the data described in this doc \nprimarily\n with the purpose of (dis)confirming the following hypothesis:\n\n\nIf Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials.\n\n\nIn service to validating the above hypothesis, we plan on answering these specific questions, given the data we plan to collect (see \nList of Proposed Events\n):\n\n\nNote that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both\n\n\n\n\nAre users using Lockbox to retrieve credentials?\n\n\nFor different intervals of time (e.g. day, week, month), what is:\n\n\nThe average rate with which a user retrieves a credential or reveals a password\n\n\nThe distribution of above rates across all users\n\n\n\n\n\n\n\n\n\n\nHow often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app?\n\n\nOnce downloaded, do users continue to use the app? (i.e., how well are they retained?)\n\n\nWe will count a user as retained in a given time interval if they perform one of the following actions:\n\n\nDisplay the credential list\n\n\nTap a credential in the credential list\n\n\nCopy a credential to the clipboard\n\n\nReveal a password\n\n\nAutofill a credential stored in Lockbox into another app\n\n\nTap the URI associated with a credential (to open it in an app or browser)\n\n\n\n\n\n\nSince they can be performed automatically, we will \nnot\n count a user as retained if they \nonly\n perform the following actions (in absence of any in the list above):\n\n\nUnlock their credentials\n\n\nSync their credentials from the Firefox desktop browser\n\n\n\n\n\n\n\n\n\n\nDoes requiring a Firefox Account constitute a roadblock to adoption?\n\n\nWhat proportion of new Lockbox users are pre-existing Firefox Account users?\n\n\nWhat proportion of users start the Account sign-in process but never complete it?\n\n\n\n\n\n\nDoes adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)?\n\n\nDo users set the default browser in Lockbox to be a Firefox browser?\n\n\n\n\n\n\n\n\nIn addition to answering the above questions that directly concern actions in the app, we will also be analyzing telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app).\n\n\nCollection\n\n\nNote: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK.\n\n\nData will be collected using this library:\n\n\nhttps://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md\n\n\nWe plan to submit two ping types, both of which are implemented by the component above.\n\n\nFirst is the \ncore ping\n, which contains information about the Android version, architecture, etc of the device Lockbox has been installed on:\n\n\nhttps://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html\n\n\nThe second is the \nevent ping\n which allows us to record event telemetry:\n\n\nhttps://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service\n\n\nTODO: link to the Lockbox for Android source code at the point where the pings and event values are defined (when that code exists).\n\n\nSee \nthis\n for the kotlin source code that Firefox Focus uses to define its telemetry events.\n\n\nEvery event must contain \ncategory\n, \nmethod\n and \nobject\n fields, and may optionally contain \nvalue\n and \nextra\n fields as well.\n\n\nEvents related to specific credentials should have an opaque \nitem_id\n in the extra field where possible.\n\n\nFinally, the \nappName\n metadata sent with each ping should always be \nLockbox\n.\n\n\nSee here for more information on event schemas:\n\n\nhttps://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api\n\n\nList of Proposed Events\n\n\n\n\n\n\nWhen the app starts up:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: startup\n\n\nobject\n: app\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen locking/unlocking the app:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: lock, unlock, autolock\n\n\nobject\n: app\n\n\nvalue\n: pin, biometrics\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nEvents that fire during the setup process:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: show\n\n\nobject\n: login_welcome, login_fxa, login_learn_more, biometrics_setup, autofill_setup\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen the main item list is shown to the user:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: show\n\n\nobject\n: entry_list\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen a user shows the details of an item in the entry list:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: show\n\n\nobject\n: entry_detail\n\n\nvalue\n: null\n\n\nextras\n: [\"itemid\" : itemid]\n\n\n\n\n\n\n\n\nWhen a user taps one of the copy buttons available after being shown entry details:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: tap\n\n\nobject\n: entry_copy_username_button, entry_copy_password_button\n\n\nvalue\n: null\n\n\nextras\n: [\"itemid\" : itemid]\n\n\n\n\n\n\n\n\nWhen a user shows details from an item, is the password shown?:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: tap\n\n\nobject\n: reveal_password\n\n\nvalue\n: true or false, whether the pw is displayed\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen one of the settings pages is shown to the user:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: show\n\n\nobject\n: settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen a user changes something on the settings page:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: settingsChanged (\nnote this was camelCase in iOS by mistake so leaving it to match that until/if we change it there\n)\n\n\nobject\n: settings_biometric_login, settings_autolock_time, settings_reset\n\n\nvalue\n: whatever the value of each of the above was changed to, or null for settings_reset\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen the app enters the background or foreground:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: background, foreground\n\n\nobject\n: app\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nEvents related to autofill:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: autofill_locked, autofill_unlocked, login_selected, autofill_clear\n\n\nobject\n: autofill\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nWhen the user opens the app drawer:\n\n\n\n\ncategory\n: action\n\n\nmethod\n: show\n\n\nobject\n: app_drawer\n\n\nvalue\n: null\n\n\nextras\n: null\n\n\n\n\n\n\n\n\nAdjust SDK\n\n\nThe app also includes a version of the \nadjust SDK\n. Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app.\n\n\nReferences\n\n\nLibrary used to collect and send telemetry on Android\n\n\nDescription of the \"Core\" ping\n\n\nDescription of the \"Focus Event\" Ping\n\n\nDescription of Event Schemas in General", 
            "title": "Telemetry and Metrics"
        }, 
        {
            "location": "/metrics/#firefox-lockbox-for-android-metrics-plan", 
            "text": "Last Updated: October 8, 2018    Analysis  Collection  List of Proposed Events  Adjust SDK  References    This is the metrics collection plan for the Lockbox Android app. It documents all events that are planned to be collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found  here .", 
            "title": "Firefox Lockbox for Android Metrics Plan"
        }, 
        {
            "location": "/metrics/#analysis", 
            "text": "Data collection is done solely for the purpose of product development, improvement and maintenance.  We will analyze the data described in this doc  primarily  with the purpose of (dis)confirming the following hypothesis:  If Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials.  In service to validating the above hypothesis, we plan on answering these specific questions, given the data we plan to collect (see  List of Proposed Events ):  Note that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both   Are users using Lockbox to retrieve credentials?  For different intervals of time (e.g. day, week, month), what is:  The average rate with which a user retrieves a credential or reveals a password  The distribution of above rates across all users      How often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app?  Once downloaded, do users continue to use the app? (i.e., how well are they retained?)  We will count a user as retained in a given time interval if they perform one of the following actions:  Display the credential list  Tap a credential in the credential list  Copy a credential to the clipboard  Reveal a password  Autofill a credential stored in Lockbox into another app  Tap the URI associated with a credential (to open it in an app or browser)    Since they can be performed automatically, we will  not  count a user as retained if they  only  perform the following actions (in absence of any in the list above):  Unlock their credentials  Sync their credentials from the Firefox desktop browser      Does requiring a Firefox Account constitute a roadblock to adoption?  What proportion of new Lockbox users are pre-existing Firefox Account users?  What proportion of users start the Account sign-in process but never complete it?    Does adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)?  Do users set the default browser in Lockbox to be a Firefox browser?     In addition to answering the above questions that directly concern actions in the app, we will also be analyzing telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app).", 
            "title": "Analysis"
        }, 
        {
            "location": "/metrics/#collection", 
            "text": "Note: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK.  Data will be collected using this library:  https://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md  We plan to submit two ping types, both of which are implemented by the component above.  First is the  core ping , which contains information about the Android version, architecture, etc of the device Lockbox has been installed on:  https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html  The second is the  event ping  which allows us to record event telemetry:  https://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service  TODO: link to the Lockbox for Android source code at the point where the pings and event values are defined (when that code exists).  See  this  for the kotlin source code that Firefox Focus uses to define its telemetry events.  Every event must contain  category ,  method  and  object  fields, and may optionally contain  value  and  extra  fields as well.  Events related to specific credentials should have an opaque  item_id  in the extra field where possible.  Finally, the  appName  metadata sent with each ping should always be  Lockbox .  See here for more information on event schemas:  https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api", 
            "title": "Collection"
        }, 
        {
            "location": "/metrics/#list-of-proposed-events", 
            "text": "When the app starts up:   category : action  method : startup  object : app  value : null  extras : null     When locking/unlocking the app:   category : action  method : lock, unlock, autolock  object : app  value : pin, biometrics  extras : null     Events that fire during the setup process:   category : action  method : show  object : login_welcome, login_fxa, login_learn_more, biometrics_setup, autofill_setup  value : null  extras : null     When the main item list is shown to the user:   category : action  method : show  object : entry_list  value : null  extras : null     When a user shows the details of an item in the entry list:   category : action  method : show  object : entry_detail  value : null  extras : [\"itemid\" : itemid]     When a user taps one of the copy buttons available after being shown entry details:   category : action  method : tap  object : entry_copy_username_button, entry_copy_password_button  value : null  extras : [\"itemid\" : itemid]     When a user shows details from an item, is the password shown?:   category : action  method : tap  object : reveal_password  value : true or false, whether the pw is displayed  extras : null     When one of the settings pages is shown to the user:   category : action  method : show  object : settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback  value : null  extras : null     When a user changes something on the settings page:   category : action  method : settingsChanged ( note this was camelCase in iOS by mistake so leaving it to match that until/if we change it there )  object : settings_biometric_login, settings_autolock_time, settings_reset  value : whatever the value of each of the above was changed to, or null for settings_reset  extras : null     When the app enters the background or foreground:   category : action  method : background, foreground  object : app  value : null  extras : null     Events related to autofill:   category : action  method : autofill_locked, autofill_unlocked, login_selected, autofill_clear  object : autofill  value : null  extras : null     When the user opens the app drawer:   category : action  method : show  object : app_drawer  value : null  extras : null", 
            "title": "List of Proposed Events"
        }, 
        {
            "location": "/metrics/#adjust-sdk", 
            "text": "The app also includes a version of the  adjust SDK . Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app.", 
            "title": "Adjust SDK"
        }, 
        {
            "location": "/metrics/#references", 
            "text": "Library used to collect and send telemetry on Android  Description of the \"Core\" ping  Description of the \"Focus Event\" Ping  Description of Event Schemas in General", 
            "title": "References"
        }, 
        {
            "location": "/install/", 
            "text": "Required Libraries\n\n\nOur linting configuration requires you to have an up-to-date installation of\n\nktlint\n\n\nSteps to Run / Build\n\n\n\n\n\n\nInstall the latest Android Studio\n\n\n\n\n\n\nClone the repository\n\n\n\n\n\n\nOpen the project in Android Studio\n\n\n\n\n\n\nGradle Sync \n build/run the project", 
            "title": "Build and Install"
        }, 
        {
            "location": "/install/#required-libraries", 
            "text": "Our linting configuration requires you to have an up-to-date installation of ktlint", 
            "title": "Required Libraries"
        }, 
        {
            "location": "/install/#steps-to-run-build", 
            "text": "Install the latest Android Studio    Clone the repository    Open the project in Android Studio    Gradle Sync   build/run the project", 
            "title": "Steps to Run / Build"
        }, 
        {
            "location": "/architecture/flux/", 
            "text": "Firefox Lockbox for Android Architecture\n\n\nRxKotlin\n\n\nFirefox Lockbox for Android makes extensive use of RxKotlin, an implementation of the Observable pattern from ReactiveX. More information and many marble diagrams can be found in the \nReactiveX documentation\n. The rest of this document relies on a basic understanding of the reader of the ReactiveX-style Observer implementation. Their intro document is a \ngood starting point\n.\n\n\nFlux\n\n\nArchitecture Pattern\n\n\nIn short, Flux architecture design maintains a unidirectional data flow, in which a global Dispatcher receives Actions \n dispatches them to appropriate Stores. The Stores, in turn, process data \n provide the source of truth for the Views. As users interact with the Views, any updates are made via a dispatched Action and the cycle begins again. See this \nflux architecture\n writeup for more details on the original Flux architecture scheme.\n\n\nLockbox implements a modified version of the described architecture (LockFlux), keeping in mind that the original implementation ignores asynchronous work. In this implementation, all asynchronous work is handled by the Stores as they reduce actions and state updates to their observable state.\n\n\nMemory Management\n\n\nThe five major components of this architecture (\nView\n, \nPresenter\n, \nStore\n, \nDispatcher\n, and \nAction\n) have distinct lifecycle management based on their functions.\n\n\nView\n/\nPresenter\n pairs are allocated and de-allocated as views get displayed or hidden in turn.\n\n\nStore\ns and the \nDispatcher\n are global singleton objects, meaning that they get lazy-loaded by the application as their shared members get accessed by the \nPresenter\ns for view configuration or dispatching.\n\n\nAction\ns get deallocated as soon as they reach the end observer for their intended function.\n\n\nView/Presenter\n\n\nAll views are bound to a presenter. In this separation, the presenter is responsible for all business logic, and the view is abstracted to a simple interface. The view is responsible for UI-specific configuration and passing user input to its presenter for handling. This allows any complex view-related configuration to be abstracted when dealing with business logic changes, and vice versa.\n\n\nIn the current implementation of LockFlux on Android, all \nView\ns are composed of Fragments, not Activities. Situations requiring an \nActivity\n to be added to the application will be reviewed on a case-to-case basis.\n\n\nAction\n\n\nActions are tiny \nenum\ns or \nsealed class\nes that contain declarative language about either the triggering user action or the update request for a given \nStore\n.\n\n\nDispatcher\n\n\nThe dispatcher class is the simplest in the application; it provides an \nAction\n-accepting method as a wrapper for the \nPublishSubject\nAction\n that publishes all dispatched actions to interested \nStores\n:\n\n\nclass Dispatcher {\n    companion object {\n        val shared = Dispatcher()\n    }\n\n    private val actionSubject = PublishSubject.create\nAction\n()\n\n    val register: Observable\nAction\n = this.actionSubject\n\n    fun dispatch(action: Action) {\n        this.actionSubject.onNext(action)\n    }\n}\n\n\n\n\nStore\n\n\nStores provide an opaque wrapper around system storage or simple \nReplay- /Publish- Subject\ns for the purposes of data access and view configuration. They selectively \nregister\n with the \nDispatcher\n for the \nAction\ns that they care about for updating state.\n\n\nStores also perform any asynchronous tasks that relate to the updating of their local state. The \nAction\ns dispatched by \nPresenter\ns are completely decoupled from observed \nStore\n state, removing the need for callback configurations.\n\n\nIt's important to note that there is no concept of ordering; all \nAction\ns will be delivered to \nStore\ns in realtime as they are dispatched.\n\n\nView Routing\n\n\nThe special case in this scenario is view routing. To handle the view-changing component of the architecture, there is a \nRouteStore\n observed by a \nRoutePresenter\n that rides along on the back of a \nRootActivity\n. This \u201ccontaining\u201d activity is not displayed to the user; rather, it performs the role of listening for navigation-specific \nAction\ns \n performing the necessary top-level fragment swapping and back stack manipulation. Routing logic lives entirely separately from individual view configuration logic, allowing for modular view manipulation and easy testing.\n\n\nBenefits of Flux\n\n\nClose readers will note that this document borrows heavily from a similar one in our \niOS application\n.\n\n\nThe shared Flux pattern and reactive libraries allow us to \"borrow\" view-presentation logic from iOS as we move forward on Android.\n\n\nAdditionally, the separation of high-level view manipulation from view allows us to iterate quickly on implementation details and design feedback without implications for unrelated parts of the app.", 
            "title": "Flux Architecture"
        }, 
        {
            "location": "/architecture/flux/#firefox-lockbox-for-android-architecture", 
            "text": "", 
            "title": "Firefox Lockbox for Android Architecture"
        }, 
        {
            "location": "/architecture/flux/#rxkotlin", 
            "text": "Firefox Lockbox for Android makes extensive use of RxKotlin, an implementation of the Observable pattern from ReactiveX. More information and many marble diagrams can be found in the  ReactiveX documentation . The rest of this document relies on a basic understanding of the reader of the ReactiveX-style Observer implementation. Their intro document is a  good starting point .", 
            "title": "RxKotlin"
        }, 
        {
            "location": "/architecture/flux/#flux", 
            "text": "", 
            "title": "Flux"
        }, 
        {
            "location": "/architecture/flux/#architecture-pattern", 
            "text": "In short, Flux architecture design maintains a unidirectional data flow, in which a global Dispatcher receives Actions   dispatches them to appropriate Stores. The Stores, in turn, process data   provide the source of truth for the Views. As users interact with the Views, any updates are made via a dispatched Action and the cycle begins again. See this  flux architecture  writeup for more details on the original Flux architecture scheme.  Lockbox implements a modified version of the described architecture (LockFlux), keeping in mind that the original implementation ignores asynchronous work. In this implementation, all asynchronous work is handled by the Stores as they reduce actions and state updates to their observable state.", 
            "title": "Architecture Pattern"
        }, 
        {
            "location": "/architecture/flux/#memory-management", 
            "text": "The five major components of this architecture ( View ,  Presenter ,  Store ,  Dispatcher , and  Action ) have distinct lifecycle management based on their functions.  View / Presenter  pairs are allocated and de-allocated as views get displayed or hidden in turn.  Store s and the  Dispatcher  are global singleton objects, meaning that they get lazy-loaded by the application as their shared members get accessed by the  Presenter s for view configuration or dispatching.  Action s get deallocated as soon as they reach the end observer for their intended function.", 
            "title": "Memory Management"
        }, 
        {
            "location": "/architecture/flux/#viewpresenter", 
            "text": "All views are bound to a presenter. In this separation, the presenter is responsible for all business logic, and the view is abstracted to a simple interface. The view is responsible for UI-specific configuration and passing user input to its presenter for handling. This allows any complex view-related configuration to be abstracted when dealing with business logic changes, and vice versa.  In the current implementation of LockFlux on Android, all  View s are composed of Fragments, not Activities. Situations requiring an  Activity  to be added to the application will be reviewed on a case-to-case basis.", 
            "title": "View/Presenter"
        }, 
        {
            "location": "/architecture/flux/#action", 
            "text": "Actions are tiny  enum s or  sealed class es that contain declarative language about either the triggering user action or the update request for a given  Store .", 
            "title": "Action"
        }, 
        {
            "location": "/architecture/flux/#dispatcher", 
            "text": "The dispatcher class is the simplest in the application; it provides an  Action -accepting method as a wrapper for the  PublishSubject Action  that publishes all dispatched actions to interested  Stores :  class Dispatcher {\n    companion object {\n        val shared = Dispatcher()\n    }\n\n    private val actionSubject = PublishSubject.create Action ()\n\n    val register: Observable Action  = this.actionSubject\n\n    fun dispatch(action: Action) {\n        this.actionSubject.onNext(action)\n    }\n}", 
            "title": "Dispatcher"
        }, 
        {
            "location": "/architecture/flux/#store", 
            "text": "Stores provide an opaque wrapper around system storage or simple  Replay- /Publish- Subject s for the purposes of data access and view configuration. They selectively  register  with the  Dispatcher  for the  Action s that they care about for updating state.  Stores also perform any asynchronous tasks that relate to the updating of their local state. The  Action s dispatched by  Presenter s are completely decoupled from observed  Store  state, removing the need for callback configurations.  It's important to note that there is no concept of ordering; all  Action s will be delivered to  Store s in realtime as they are dispatched.", 
            "title": "Store"
        }, 
        {
            "location": "/architecture/flux/#view-routing", 
            "text": "The special case in this scenario is view routing. To handle the view-changing component of the architecture, there is a  RouteStore  observed by a  RoutePresenter  that rides along on the back of a  RootActivity . This \u201ccontaining\u201d activity is not displayed to the user; rather, it performs the role of listening for navigation-specific  Action s   performing the necessary top-level fragment swapping and back stack manipulation. Routing logic lives entirely separately from individual view configuration logic, allowing for modular view manipulation and easy testing.", 
            "title": "View Routing"
        }, 
        {
            "location": "/architecture/flux/#benefits-of-flux", 
            "text": "Close readers will note that this document borrows heavily from a similar one in our  iOS application .  The shared Flux pattern and reactive libraries allow us to \"borrow\" view-presentation logic from iOS as we move forward on Android.  Additionally, the separation of high-level view manipulation from view allows us to iterate quickly on implementation details and design feedback without implications for unrelated parts of the app.", 
            "title": "Benefits of Flux"
        }, 
        {
            "location": "/architecture/sec-apis/", 
            "text": "On Using Keys and Biometrics\n\n\nBelow are some findings on using a couple of security features in Android:\n\n\n\n\nAndroidKeyStore\n\n\nBiometrics\n\n\nDevice locks\n\n\n\n\nUsing \nAndroidKeyStore\n\n\nThe \nAndroidKeyStore\n is an implementation of the \nJava Cryptography Architecture (JCA)\n's \nKeyStore\n service to manage application-specific cryptographic keys.  Such keys can be created or imported with an associated label, then an opaque \nKey\n class obtained from that label to use for cryptographic operations.  However, they \ncannot\n be exported.  The remainder here focuses on creating rather than import.\n\n\nObtaining this Keystore is done using the static method \nKeystore.getIstance()\n and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider.\n\n\nNew keys are created using an instance of \nKeyGenerator\n (or \nKeyPairGenerator\n), again specifying \"AndroidKeyStore\" as the SPI provider.  When creating a new key, several properties can be applied via \nKeyGenParameterSpec\n, including:\n\n\n\n\nkey size (in bits)\n\n\nencryption block modes (e.g., \nGCM\n)\n\n\nencryption padding (e.g., \nNONE\n) \n\n\nrequire authentication\n\n\nduration until next authentication (in seconds)\n\n\n\n\nOnce set, these properties \ncannot\n be changed without first deleting then re-importing/-creating the key.  If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for \nevery\n use, it can only be done if the user has at least one fingerprint enrolled.\n\n\nKeys in the AndroidKeyStore are stored on the device until one of the following happens:\n\n\n\n\nThe app deletes its entry from the KeyStore\n\n\nThe app's data storage (not data cache) is cleared\n\n\nThe app is uninstalled\n\n\n\n\nKeys with user authentication required are invalided and cannot be used if any of the following happen:\n\n\n\n\nThe device is hard reset\n\n\nThe security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None)\n\n\n\n\nFurther, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen:\n\n\n\n\nA new fingerprint is enrolled\n\n\nAll fingerprints are unenrolled\n\n\n\n\nExisting Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., \n.getSecretKey()\n).  Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return \nnull\n; this is true even for PublicKeys.\n\n\nthe \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment.  If the key requires authentication, a \nUserNotAuthenticatedException\n is thrown; if the key no longer valid (as above), a \nKeyPermanentlyInvalidatedException\n is thrown.\n\n\nUsing KeyguardManager\n\n\nThe KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device.  It can only be obtained from a \nContext\n (e.g., \nActivity\n).\n\n\nThe most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked.  Both are boolean values; it is not possible to determine \nwhich\n method of lock is configured.\n\n\nIn addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of \ncreateConfirmDeviceCredentialIntent()\n; if no \"strong\" security lock is configured, this method returns \nnull\n.\n\n\nThe Intent is created with optional title and description, then dispatched via \nstartActivityForResult()\n to trigger the device prompts.  Applications receive either \nRESULT_OK\n (if successfully unlocked) or \nRESULT_CANCELED\n (device prompt is dismissed) via the overridden method \nonActivityResult()\n.  It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.\n\n\nUsing FingerprintManager\n\n\nNOTE:\n This API is marked as \ndeprecated\n as of API 28 (Android Pie) and replaced with \nBiometricPrompt\n.\n\n\nThe FingerprintManager is a system service used to interact with a device's fingerprint hardware.  This was added in API 23, and is now deprecated as of API 28.  As with \nKeyguardManager\n it can only be obtained from a \nContext\n (e.g., \nActivity\n).  It also requires the \nUSE_FINGERPRINT\n or \nUSE_BIOMETRIC\n (added in API 28) permission in the app's manifest.\n\n\nThere are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled.\n\n\nEngaging the fingerprint reader is done by calling \nauthenticate()\n.  Before doing so, the app must provide a \nFingerprintManager.CryptoObject\n and a \nFingerprintManager.AuthenticationCallback\n.  This method returns immediately; further interaction happens via the passed-in \nAuthenticationCallback\n.  An optional \nCancellationSignal\n can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button).\n\n\nThis object only engages the hardware; it does not display anything to the user itself.  The app is responsible for managing a view regarding the fingerprint reading operations.\n\n\nOnce the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.\n\n\nAbout the CryptoObject\n\n\nThe required \nCryptoObject\n wraps a \nCipher\n, \nMac\n or \nSignature\n object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.\n\n\nAbout the AuthenticationCallback\n\n\nThe required \nAuthenticationCallback\n is where events from fingerprint reader attempts are dispatched.  Subclasses need only override the event methods they are interested in.\n\n\nOn success \nonAuthenticationSuccessful()\n is called with the original \nCryptoObject\n wrapped in a \nAuthenticationResult\n.  If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use).\n\n\nA fingerprint read failure is notified via \nonAuthenticaitonFailed()\n, such as a unrecognized print.  If there is some other temporary failure (e.g., dirty reader), \nonAuthenticationHelp()\n is called with the relevant status code and a (device locale appropriate) user-directed help message.\n\n\nPermanent errors are notified via \nonAuthenticationError()\n, with the relevant status code and (device locale appropriate) user-directed error message.\n\n\nUsing BiometricPrompt\n\n\nThe BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog.  This class is introduced in API 28 to replace FingerprintManager.  The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader).\n\n\nTo create a \nBiometricPrmpt\n, a \nBiometricPrompt.Builder\n is created (with an appropriate \nContext\n) and configured.  The app can set a title, subtitle, description, and \"cancel\" button behavior.  Once created, the app calls \nauthenticate()\n (just like with \nFingerprintManager\n).\n\n\nThe hardware-engagement behavior is nearly identical to \nFingerprintManager\n; the app is notified of events via an instance of \nBiometricPrompt.AuthenticationCallback\n (which has the exact same methods as \nFingerprintManager.AuthenticationCallback\n), can be canceled via a \nCancellationSignal\n, and operates on a \nCryptoObject\n.  The biggest differences are:\n\n\n\n\nThe \nCryptoObject\n is optional\n\n\nThe app must explicitly provide an \nExecutor\n where events are dispatched (this can be \nContext.mainExecutor\n)\n\n\nThe app no longer manages any view to interact with the user.", 
            "title": "Using Keys and Biometrics"
        }, 
        {
            "location": "/architecture/sec-apis/#on-using-keys-and-biometrics", 
            "text": "Below are some findings on using a couple of security features in Android:   AndroidKeyStore  Biometrics  Device locks", 
            "title": "On Using Keys and Biometrics"
        }, 
        {
            "location": "/architecture/sec-apis/#using-androidkeystore", 
            "text": "The  AndroidKeyStore  is an implementation of the  Java Cryptography Architecture (JCA) 's  KeyStore  service to manage application-specific cryptographic keys.  Such keys can be created or imported with an associated label, then an opaque  Key  class obtained from that label to use for cryptographic operations.  However, they  cannot  be exported.  The remainder here focuses on creating rather than import.  Obtaining this Keystore is done using the static method  Keystore.getIstance()  and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider.  New keys are created using an instance of  KeyGenerator  (or  KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider.  When creating a new key, several properties can be applied via  KeyGenParameterSpec , including:   key size (in bits)  encryption block modes (e.g.,  GCM )  encryption padding (e.g.,  NONE )   require authentication  duration until next authentication (in seconds)   Once set, these properties  cannot  be changed without first deleting then re-importing/-creating the key.  If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for  every  use, it can only be done if the user has at least one fingerprint enrolled.  Keys in the AndroidKeyStore are stored on the device until one of the following happens:   The app deletes its entry from the KeyStore  The app's data storage (not data cache) is cleared  The app is uninstalled   Keys with user authentication required are invalided and cannot be used if any of the following happen:   The device is hard reset  The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None)   Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen:   A new fingerprint is enrolled  All fingerprints are unenrolled   Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g.,  .getSecretKey() ).  Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return  null ; this is true even for PublicKeys.  the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment.  If the key requires authentication, a  UserNotAuthenticatedException  is thrown; if the key no longer valid (as above), a  KeyPermanentlyInvalidatedException  is thrown.", 
            "title": "Using AndroidKeyStore"
        }, 
        {
            "location": "/architecture/sec-apis/#using-keyguardmanager", 
            "text": "The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device.  It can only be obtained from a  Context  (e.g.,  Activity ).  The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked.  Both are boolean values; it is not possible to determine  which  method of lock is configured.  In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of  createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns  null .  The Intent is created with optional title and description, then dispatched via  startActivityForResult()  to trigger the device prompts.  Applications receive either  RESULT_OK  (if successfully unlocked) or  RESULT_CANCELED  (device prompt is dismissed) via the overridden method  onActivityResult() .  It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.", 
            "title": "Using KeyguardManager"
        }, 
        {
            "location": "/architecture/sec-apis/#using-fingerprintmanager", 
            "text": "NOTE:  This API is marked as  deprecated  as of API 28 (Android Pie) and replaced with  BiometricPrompt .  The FingerprintManager is a system service used to interact with a device's fingerprint hardware.  This was added in API 23, and is now deprecated as of API 28.  As with  KeyguardManager  it can only be obtained from a  Context  (e.g.,  Activity ).  It also requires the  USE_FINGERPRINT  or  USE_BIOMETRIC  (added in API 28) permission in the app's manifest.  There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled.  Engaging the fingerprint reader is done by calling  authenticate() .  Before doing so, the app must provide a  FingerprintManager.CryptoObject  and a  FingerprintManager.AuthenticationCallback .  This method returns immediately; further interaction happens via the passed-in  AuthenticationCallback .  An optional  CancellationSignal  can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button).  This object only engages the hardware; it does not display anything to the user itself.  The app is responsible for managing a view regarding the fingerprint reading operations.  Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.", 
            "title": "Using FingerprintManager"
        }, 
        {
            "location": "/architecture/sec-apis/#about-the-cryptoobject", 
            "text": "The required  CryptoObject  wraps a  Cipher ,  Mac  or  Signature  object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.", 
            "title": "About the CryptoObject"
        }, 
        {
            "location": "/architecture/sec-apis/#about-the-authenticationcallback", 
            "text": "The required  AuthenticationCallback  is where events from fingerprint reader attempts are dispatched.  Subclasses need only override the event methods they are interested in.  On success  onAuthenticationSuccessful()  is called with the original  CryptoObject  wrapped in a  AuthenticationResult .  If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use).  A fingerprint read failure is notified via  onAuthenticaitonFailed() , such as a unrecognized print.  If there is some other temporary failure (e.g., dirty reader),  onAuthenticationHelp()  is called with the relevant status code and a (device locale appropriate) user-directed help message.  Permanent errors are notified via  onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message.", 
            "title": "About the AuthenticationCallback"
        }, 
        {
            "location": "/architecture/sec-apis/#using-biometricprompt", 
            "text": "The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog.  This class is introduced in API 28 to replace FingerprintManager.  The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader).  To create a  BiometricPrmpt , a  BiometricPrompt.Builder  is created (with an appropriate  Context ) and configured.  The app can set a title, subtitle, description, and \"cancel\" button behavior.  Once created, the app calls  authenticate()  (just like with  FingerprintManager ).  The hardware-engagement behavior is nearly identical to  FingerprintManager ; the app is notified of events via an instance of  BiometricPrompt.AuthenticationCallback  (which has the exact same methods as  FingerprintManager.AuthenticationCallback ), can be canceled via a  CancellationSignal , and operates on a  CryptoObject .  The biggest differences are:   The  CryptoObject  is optional  The app must explicitly provide an  Executor  where events are dispatched (this can be  Context.mainExecutor )  The app no longer manages any view to interact with the user.", 
            "title": "Using BiometricPrompt"
        }, 
        {
            "location": "/accessibility/", 
            "text": "Accessibility on Lockbox for Android\n\n\nOn Lockbox for Android, we implement two forms of automatic testing and\nencourage developers and testers to use the recommended forms of manual testing\nto ensure that our application is accessible to every possible user.\n\n\nAutomatic Accessibility\n\n\nLint Checks\n\n\nThese are fairly simple static analysis checks. You're probably familiar with warning pop-ups when you have small code style issues; in Lockbox for Android, the build will fail if you do not address these warnings!\n\n\nThe most important accessibility warning is the \ncontentDescription\n warning on images. This warning will appear when the \ncontentDescription\n attribute-- the text description of the image --has not been set.\n\n\nEspresso Tests\n\n\nAccessibilityChecks.enable()\n -- This should be added in setup methods for your Espresso tests.\n\n\nWhen adding new Espresso tests, you may notice failures related to things like\ntap target size. The automated Espresso accessibility checks occur on every\nmethod call in the \nViewActions\n class.\n\n\nManual Accessibility Testing\n\n\nAccessibilityScanner\n\n\nThe \nAndroid Accessibility Scanner\n is a tool used to scan your app's screen to identify potential areas of improvement.\n\n\nTalkBack\n\n\nTalkBack is a screen reader that is built into all (?) Android devices. This tool can be used to test your application by closing your eyes while attempting to navigate.\n\n\nInstructions on enabling TalkBack on your device: https://support.google.com/accessibility/android/answer/6283677?hl=en\nref_topic=3529932\n\n\nChanging Text\n\n\nA common accessibility problem arises with users who have changed their font size. Test your app by \nincreasing your device's font size\n.\n\n\nIn addition to font size, be aware of text contrast, \ncolor inversion\n, colorblindness, and color correction.", 
            "title": "Accessibility"
        }, 
        {
            "location": "/accessibility/#accessibility-on-lockbox-for-android", 
            "text": "On Lockbox for Android, we implement two forms of automatic testing and\nencourage developers and testers to use the recommended forms of manual testing\nto ensure that our application is accessible to every possible user.", 
            "title": "Accessibility on Lockbox for Android"
        }, 
        {
            "location": "/accessibility/#automatic-accessibility", 
            "text": "", 
            "title": "Automatic Accessibility"
        }, 
        {
            "location": "/accessibility/#lint-checks", 
            "text": "These are fairly simple static analysis checks. You're probably familiar with warning pop-ups when you have small code style issues; in Lockbox for Android, the build will fail if you do not address these warnings!  The most important accessibility warning is the  contentDescription  warning on images. This warning will appear when the  contentDescription  attribute-- the text description of the image --has not been set.", 
            "title": "Lint Checks"
        }, 
        {
            "location": "/accessibility/#espresso-tests", 
            "text": "AccessibilityChecks.enable()  -- This should be added in setup methods for your Espresso tests.  When adding new Espresso tests, you may notice failures related to things like\ntap target size. The automated Espresso accessibility checks occur on every\nmethod call in the  ViewActions  class.", 
            "title": "Espresso Tests"
        }, 
        {
            "location": "/accessibility/#manual-accessibility-testing", 
            "text": "", 
            "title": "Manual Accessibility Testing"
        }, 
        {
            "location": "/accessibility/#accessibilityscanner", 
            "text": "The  Android Accessibility Scanner  is a tool used to scan your app's screen to identify potential areas of improvement.", 
            "title": "AccessibilityScanner"
        }, 
        {
            "location": "/accessibility/#talkback", 
            "text": "TalkBack is a screen reader that is built into all (?) Android devices. This tool can be used to test your application by closing your eyes while attempting to navigate.  Instructions on enabling TalkBack on your device: https://support.google.com/accessibility/android/answer/6283677?hl=en ref_topic=3529932", 
            "title": "TalkBack"
        }, 
        {
            "location": "/accessibility/#changing-text", 
            "text": "A common accessibility problem arises with users who have changed their font size. Test your app by  increasing your device's font size .  In addition to font size, be aware of text contrast,  color inversion , colorblindness, and color correction.", 
            "title": "Changing Text"
        }
    ]
}