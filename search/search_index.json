{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Firefox Lockbox for Android documentation!","title":"Introduction"},{"location":"SECURITY/","text":"Mozilla Security Mozilla cares about privacy and security. For more information please see: https://www.mozilla.org/security/ If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"Mozilla Security #"},{"location":"SECURITY/#mozilla-security","text":"Mozilla cares about privacy and security. For more information please see: https://www.mozilla.org/security/ If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"Mozilla Security"},{"location":"code_of_conduct/","text":"Code of Conduct This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines .","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines .","title":"Code of Conduct"},{"location":"contributing/","text":"Contributing Thank you for considering and taking the time to contribute! The following are guidelines for contributing to this project. Code of Conduct This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines . How to Get Started Please refer to installation and build instructions in the documentation . How to Report Bugs Please open a new issue in the GitHub repository with steps to reproduce the problem you're experiencing. Be sure to include as much information including screenshots, text output, and both your expected and actual results. If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com How to Request Enhancements First, please refer to the applicable GitHub repository and search the repository's GitHub issues to make sure your idea has not been (or is not still) considered. Then, please create a new issue in the GitHub repository describing your enhancement. Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile. Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented. How to Contribute Code Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of good first issues and find something that sounds interesting. If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to file an issue first. Once you have a patch ready: Make sure all tests are passing and try to add tests for the code you've written. Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for considering and taking the time to contribute! The following are guidelines for contributing to this project.","title":"Contributing"},{"location":"contributing/#code-of-conduct","text":"This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines .","title":"Code of Conduct"},{"location":"contributing/#how-to-get-started","text":"Please refer to installation and build instructions in the documentation .","title":"How to Get Started"},{"location":"contributing/#how-to-report-bugs","text":"Please open a new issue in the GitHub repository with steps to reproduce the problem you're experiencing. Be sure to include as much information including screenshots, text output, and both your expected and actual results. If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"How to Report Bugs"},{"location":"contributing/#how-to-request-enhancements","text":"First, please refer to the applicable GitHub repository and search the repository's GitHub issues to make sure your idea has not been (or is not still) considered. Then, please create a new issue in the GitHub repository describing your enhancement. Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile. Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.","title":"How to Request Enhancements"},{"location":"contributing/#how-to-contribute-code","text":"Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of good first issues and find something that sounds interesting. If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to file an issue first. Once you have a patch ready: Make sure all tests are passing and try to add tests for the code you've written. Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.","title":"How to Contribute Code"},{"location":"install/","text":"Install the latest Android Studio Clone the repository Open the project in Android Studio Build/Run the project","title":"Build and Install"},{"location":"metrics/","text":"Firefox Lockbox for Android Metrics Plan Last Updated: October 8, 2018 Analysis Collection List of Proposed Events Adjust SDK References This is the metrics collection plan for the Lockbox Android app. It documents all events that are planned to be collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found here . Analysis Data collection is done solely for the purpose of product development, improvement and maintenance. We will analyze the data described in this doc primarily with the purpose of (dis)confirming the following hypothesis: If Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials. In service to validating the above hypothesis, we plan on answering these specific questions, given the data we plan to collect (see List of Proposed Events ): Note that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both Are users using Lockbox to retrieve credentials? For different intervals of time (e.g. day, week, month), what is: The average rate with which a user retrieves a credential or reveals a password The distribution of above rates across all users How often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app? Once downloaded, do users continue to use the app? (i.e., how well are they retained?) We will count a user as retained in a given time interval if they perform one of the following actions: Display the credential list Tap a credential in the credential list Copy a credential to the clipboard Reveal a password Autofill a credential stored in Lockbox into another app Tap the URI associated with a credential (to open it in an app or browser) Since they can be performed automatically, we will not count a user as retained if they only perform the following actions (in absence of any in the list above): Unlock their credentials Sync their credentials from the Firefox desktop browser Does requiring a Firefox Account constitute a roadblock to adoption? What proportion of new Lockbox users are pre-existing Firefox Account users? What proportion of users start the Account sign-in process but never complete it? Does adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)? Do users set the default browser in Lockbox to be a Firefox browser? In addition to answering the above questions that directly concern actions in the app, we will also be analyzing telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app). Collection Note: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK. Data will be collected using this library: https://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md We plan to submit two ping types, both of which are implemented by the component above. First is the core ping , which contains information about the Android version, architecture, etc of the device Lockbox has been installed on: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html The second is the event ping which allows us to record event telemetry: https://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service TODO: link to the Lockbox for Android source code at the point where the pings and event values are defined (when that code exists). See this for the kotlin source code that Firefox Focus uses to define its telemetry events. Every event must contain category , method and object fields, and may optionally contain value and extra fields as well. Events related to specific credentials should have an opaque item_id in the extra field where possible. Finally, the appName metadata sent with each ping should always be Lockbox . See here for more information on event schemas: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api List of Proposed Events When the app starts up: category : action method : startup object : app value : null extras : null When locking/unlocking the app: category : action method : lock, unlock, autolock object : app value : pin, biometrics extras : null Events that fire during the setup process: category : action method : show object : login_welcome, login_fxa, login_learn_more, biometrics_setup, autofill_setup value : null extras : null When the main item list is shown to the user: category : action method : show object : entry_list value : null extras : null When a user shows the details of an item in the entry list: category : action method : show object : entry_detail value : null extras : [\"itemid\" : itemid] When a user taps one of the copy buttons available after being shown entry details: category : action method : tap object : entry_copy_username_button, entry_copy_password_button value : null extras : [\"itemid\" : itemid] When a user shows details from an item, is the password shown?: category : action method : tap object : reveal_password value : true or false, whether the pw is displayed extras : null When one of the settings pages is shown to the user: category : action method : show object : settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback value : null extras : null When a user changes something on the settings page: category : action method : settingsChanged ( note this was camelCase in iOS by mistake so leaving it to match that until/if we change it there ) object : settings_biometric_login, settings_autolock_time, settings_reset value : whatever the value of each of the above was changed to, or null for settings_reset extras : null When the app enters the background or foreground: category : action method : background, foreground object : app value : null extras : null Events related to autofill: category : action method : autofill_locked, autofill_unlocked, login_selected, autofill_clear object : autofill value : null extras : null When the user opens the app drawer: category : action method : show object : app_drawer value : null extras : null Adjust SDK The app also includes a version of the adjust SDK . Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app. References Library used to collect and send telemetry on Android Description of the \"Core\" ping Description of the \"Focus Event\" Ping Description of Event Schemas in General","title":"Telemetry and Metrics"},{"location":"metrics/#firefox-lockbox-for-android-metrics-plan","text":"Last Updated: October 8, 2018 Analysis Collection List of Proposed Events Adjust SDK References This is the metrics collection plan for the Lockbox Android app. It documents all events that are planned to be collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found here .","title":"Firefox Lockbox for Android Metrics Plan"},{"location":"metrics/#analysis","text":"Data collection is done solely for the purpose of product development, improvement and maintenance. We will analyze the data described in this doc primarily with the purpose of (dis)confirming the following hypothesis: If Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials. In service to validating the above hypothesis, we plan on answering these specific questions, given the data we plan to collect (see List of Proposed Events ): Note that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both Are users using Lockbox to retrieve credentials? For different intervals of time (e.g. day, week, month), what is: The average rate with which a user retrieves a credential or reveals a password The distribution of above rates across all users How often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app? Once downloaded, do users continue to use the app? (i.e., how well are they retained?) We will count a user as retained in a given time interval if they perform one of the following actions: Display the credential list Tap a credential in the credential list Copy a credential to the clipboard Reveal a password Autofill a credential stored in Lockbox into another app Tap the URI associated with a credential (to open it in an app or browser) Since they can be performed automatically, we will not count a user as retained if they only perform the following actions (in absence of any in the list above): Unlock their credentials Sync their credentials from the Firefox desktop browser Does requiring a Firefox Account constitute a roadblock to adoption? What proportion of new Lockbox users are pre-existing Firefox Account users? What proportion of users start the Account sign-in process but never complete it? Does adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)? Do users set the default browser in Lockbox to be a Firefox browser? In addition to answering the above questions that directly concern actions in the app, we will also be analyzing telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app).","title":"Analysis"},{"location":"metrics/#collection","text":"Note: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK. Data will be collected using this library: https://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md We plan to submit two ping types, both of which are implemented by the component above. First is the core ping , which contains information about the Android version, architecture, etc of the device Lockbox has been installed on: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html The second is the event ping which allows us to record event telemetry: https://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service TODO: link to the Lockbox for Android source code at the point where the pings and event values are defined (when that code exists). See this for the kotlin source code that Firefox Focus uses to define its telemetry events. Every event must contain category , method and object fields, and may optionally contain value and extra fields as well. Events related to specific credentials should have an opaque item_id in the extra field where possible. Finally, the appName metadata sent with each ping should always be Lockbox . See here for more information on event schemas: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api","title":"Collection"},{"location":"metrics/#list-of-proposed-events","text":"When the app starts up: category : action method : startup object : app value : null extras : null When locking/unlocking the app: category : action method : lock, unlock, autolock object : app value : pin, biometrics extras : null Events that fire during the setup process: category : action method : show object : login_welcome, login_fxa, login_learn_more, biometrics_setup, autofill_setup value : null extras : null When the main item list is shown to the user: category : action method : show object : entry_list value : null extras : null When a user shows the details of an item in the entry list: category : action method : show object : entry_detail value : null extras : [\"itemid\" : itemid] When a user taps one of the copy buttons available after being shown entry details: category : action method : tap object : entry_copy_username_button, entry_copy_password_button value : null extras : [\"itemid\" : itemid] When a user shows details from an item, is the password shown?: category : action method : tap object : reveal_password value : true or false, whether the pw is displayed extras : null When one of the settings pages is shown to the user: category : action method : show object : settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback value : null extras : null When a user changes something on the settings page: category : action method : settingsChanged ( note this was camelCase in iOS by mistake so leaving it to match that until/if we change it there ) object : settings_biometric_login, settings_autolock_time, settings_reset value : whatever the value of each of the above was changed to, or null for settings_reset extras : null When the app enters the background or foreground: category : action method : background, foreground object : app value : null extras : null Events related to autofill: category : action method : autofill_locked, autofill_unlocked, login_selected, autofill_clear object : autofill value : null extras : null When the user opens the app drawer: category : action method : show object : app_drawer value : null extras : null","title":"List of Proposed Events"},{"location":"metrics/#adjust-sdk","text":"The app also includes a version of the adjust SDK . Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app.","title":"Adjust SDK"},{"location":"metrics/#references","text":"Library used to collect and send telemetry on Android Description of the \"Core\" ping Description of the \"Focus Event\" Ping Description of Event Schemas in General","title":"References"},{"location":"architecture/sec-apis/","text":"On Using Keys and Biometrics Below are some findings on using a couple of security features in Android: AndroidKeyStore Biometrics Device locks Using AndroidKeyStore The AndroidKeyStore is an implementation of the Java Cryptography Architecture (JCA) 's KeyStore service to manage application-specific cryptographic keys. Such keys can be created or imported with an associated label, then an opaque Key class obtained from that label to use for cryptographic operations. However, they cannot be exported. The remainder here focuses on creating rather than import. Obtaining this Keystore is done using the static method Keystore.getIstance() and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider. New keys are created using an instance of KeyGenerator (or KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider. When creating a new key, several properties can be applied via KeyGenParameterSpec , including: key size (in bits) encryption block modes (e.g., GCM ) encryption padding (e.g., NONE ) require authentication duration until next authentication (in seconds) Once set, these properties cannot be changed without first deleting then re-importing/-creating the key. If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for every use, it can only be done if the user has at least one fingerprint enrolled. Keys in the AndroidKeyStore are stored on the device until one of the following happens: The app deletes its entry from the KeyStore The app's data storage (not data cache) is cleared The app is uninstalled Keys with user authentication required are invalided and cannot be used if any of the following happen: The device is hard reset The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None) Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen: A new fingerprint is enrolled All fingerprints are unenrolled Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., .getSecretKey() ). Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return null ; this is true even for PublicKeys. the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment. If the key requires authentication, a UserNotAuthenticatedException is thrown; if the key no longer valid (as above), a KeyPermanentlyInvalidatedException is thrown. Using KeyguardManager The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device. It can only be obtained from a Context (e.g., Activity ). The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked. Both are boolean values; it is not possible to determine which method of lock is configured. In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns null . The Intent is created with optional title and description, then dispatched via startActivityForResult() to trigger the device prompts. Applications receive either RESULT_OK (if successfully unlocked) or RESULT_CANCELED (device prompt is dismissed) via the overridden method onActivityResult() . It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received. Using FingerprintManager NOTE: This API is marked as deprecated as of API 28 (Android Pie) and replaced with BiometricPrompt . The FingerprintManager is a system service used to interact with a device's fingerprint hardware. This was added in API 23, and is now deprecated as of API 28. As with KeyguardManager it can only be obtained from a Context (e.g., Activity ). It also requires the USE_FINGERPRINT or USE_BIOMETRIC (added in API 28) permission in the app's manifest. There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled. Engaging the fingerprint reader is done by calling authenticate() . Before doing so, the app must provide a FingerprintManager.CryptoObject and a FingerprintManager.AuthenticationCallback . This method returns immediately; further interaction happens via the passed-in AuthenticationCallback . An optional CancellationSignal can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button). This object only engages the hardware; it does not display anything to the user itself. The app is responsible for managing a view regarding the fingerprint reading operations. Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained. About the CryptoObject The required CryptoObject wraps a Cipher , Mac or Signature object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used. About the AuthenticationCallback The required AuthenticationCallback is where events from fingerprint reader attempts are dispatched. Subclasses need only override the event methods they are interested in. On success onAuthenticationSuccessful() is called with the original CryptoObject wrapped in a AuthenticationResult . If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use). A fingerprint read failure is notified via onAuthenticaitonFailed() , such as a unrecognized print. If there is some other temporary failure (e.g., dirty reader), onAuthenticationHelp() is called with the relevant status code and a (device locale appropriate) user-directed help message. Permanent errors are notified via onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message. Using BiometricPrompt The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog. This class is introduced in API 28 to replace FingerprintManager. The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader). To create a BiometricPrmpt , a BiometricPrompt.Builder is created (with an appropriate Context ) and configured. The app can set a title, subtitle, description, and \"cancel\" button behavior. Once created, the app calls authenticate() (just like with FingerprintManager ). The hardware-engagement behavior is nearly identical to FingerprintManager ; the app is notified of events via an instance of BiometricPrompt.AuthenticationCallback (which has the exact same methods as FingerprintManager.AuthenticationCallback ), can be canceled via a CancellationSignal , and operates on a CryptoObject . The biggest differences are: The CryptoObject is optional The app must explicitly provide an Executor where events are dispatched (this can be Context.mainExecutor ) The app no longer manages any view to interact with the user.","title":"Using Keys and Biometrics"},{"location":"architecture/sec-apis/#on-using-keys-and-biometrics","text":"Below are some findings on using a couple of security features in Android: AndroidKeyStore Biometrics Device locks","title":"On Using Keys and Biometrics"},{"location":"architecture/sec-apis/#using-androidkeystore","text":"The AndroidKeyStore is an implementation of the Java Cryptography Architecture (JCA) 's KeyStore service to manage application-specific cryptographic keys. Such keys can be created or imported with an associated label, then an opaque Key class obtained from that label to use for cryptographic operations. However, they cannot be exported. The remainder here focuses on creating rather than import. Obtaining this Keystore is done using the static method Keystore.getIstance() and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider. New keys are created using an instance of KeyGenerator (or KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider. When creating a new key, several properties can be applied via KeyGenParameterSpec , including: key size (in bits) encryption block modes (e.g., GCM ) encryption padding (e.g., NONE ) require authentication duration until next authentication (in seconds) Once set, these properties cannot be changed without first deleting then re-importing/-creating the key. If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for every use, it can only be done if the user has at least one fingerprint enrolled. Keys in the AndroidKeyStore are stored on the device until one of the following happens: The app deletes its entry from the KeyStore The app's data storage (not data cache) is cleared The app is uninstalled Keys with user authentication required are invalided and cannot be used if any of the following happen: The device is hard reset The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None) Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen: A new fingerprint is enrolled All fingerprints are unenrolled Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., .getSecretKey() ). Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return null ; this is true even for PublicKeys. the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment. If the key requires authentication, a UserNotAuthenticatedException is thrown; if the key no longer valid (as above), a KeyPermanentlyInvalidatedException is thrown.","title":"Using AndroidKeyStore"},{"location":"architecture/sec-apis/#using-keyguardmanager","text":"The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device. It can only be obtained from a Context (e.g., Activity ). The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked. Both are boolean values; it is not possible to determine which method of lock is configured. In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns null . The Intent is created with optional title and description, then dispatched via startActivityForResult() to trigger the device prompts. Applications receive either RESULT_OK (if successfully unlocked) or RESULT_CANCELED (device prompt is dismissed) via the overridden method onActivityResult() . It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.","title":"Using KeyguardManager"},{"location":"architecture/sec-apis/#using-fingerprintmanager","text":"NOTE: This API is marked as deprecated as of API 28 (Android Pie) and replaced with BiometricPrompt . The FingerprintManager is a system service used to interact with a device's fingerprint hardware. This was added in API 23, and is now deprecated as of API 28. As with KeyguardManager it can only be obtained from a Context (e.g., Activity ). It also requires the USE_FINGERPRINT or USE_BIOMETRIC (added in API 28) permission in the app's manifest. There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled. Engaging the fingerprint reader is done by calling authenticate() . Before doing so, the app must provide a FingerprintManager.CryptoObject and a FingerprintManager.AuthenticationCallback . This method returns immediately; further interaction happens via the passed-in AuthenticationCallback . An optional CancellationSignal can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button). This object only engages the hardware; it does not display anything to the user itself. The app is responsible for managing a view regarding the fingerprint reading operations. Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.","title":"Using FingerprintManager"},{"location":"architecture/sec-apis/#about-the-cryptoobject","text":"The required CryptoObject wraps a Cipher , Mac or Signature object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.","title":"About the CryptoObject"},{"location":"architecture/sec-apis/#about-the-authenticationcallback","text":"The required AuthenticationCallback is where events from fingerprint reader attempts are dispatched. Subclasses need only override the event methods they are interested in. On success onAuthenticationSuccessful() is called with the original CryptoObject wrapped in a AuthenticationResult . If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use). A fingerprint read failure is notified via onAuthenticaitonFailed() , such as a unrecognized print. If there is some other temporary failure (e.g., dirty reader), onAuthenticationHelp() is called with the relevant status code and a (device locale appropriate) user-directed help message. Permanent errors are notified via onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message.","title":"About the AuthenticationCallback"},{"location":"architecture/sec-apis/#using-biometricprompt","text":"The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog. This class is introduced in API 28 to replace FingerprintManager. The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader). To create a BiometricPrmpt , a BiometricPrompt.Builder is created (with an appropriate Context ) and configured. The app can set a title, subtitle, description, and \"cancel\" button behavior. Once created, the app calls authenticate() (just like with FingerprintManager ). The hardware-engagement behavior is nearly identical to FingerprintManager ; the app is notified of events via an instance of BiometricPrompt.AuthenticationCallback (which has the exact same methods as FingerprintManager.AuthenticationCallback ), can be canceled via a CancellationSignal , and operates on a CryptoObject . The biggest differences are: The CryptoObject is optional The app must explicitly provide an Executor where events are dispatched (this can be Context.mainExecutor ) The app no longer manages any view to interact with the user.","title":"Using BiometricPrompt"}]}