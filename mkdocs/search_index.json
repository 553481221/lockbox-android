{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Firefox Lockbox for Android documentation!", 
            "title": "Introduction"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nThank you for considering and taking the time to contribute!\n\n\nThe following are guidelines for contributing to this project.\n\n\nCode of Conduct\n\n\nThis repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the \nMozilla Community Participation Guidelines\n and \nDeveloper Etiquette Guidelines\n.\n\n\nHow to Get Started\n\n\nPlease refer to installation and build instructions in the \ndocumentation\n.\n\n\nHow to Report Bugs\n\n\nPlease open \na new issue in the GitHub repository\n with steps to reproduce the problem you're experiencing.\n\n\nBe sure to include as much information including screenshots, text output, and both your expected and actual results.\n\n\nHow to Request Enhancements\n\n\nFirst, please refer to the applicable \nGitHub repository\n and search \nthe repository's GitHub issues\n to make sure your idea has not been (or is not still) considered.\n\n\nThen, please \ncreate a new issue in the GitHub repository\n describing your enhancement.\n\n\nBe sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile.\n\n\nPlease keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.\n\n\nHow to Contribute Code\n\n\nBefore you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of \ngood first issues\n and find something that sounds interesting.\n\n\nIf there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to \nfile an issue\n first.\n\n\nOnce you have a patch ready:\n\n\n\n\nMake sure all tests are passing and try to add tests for the code you've written. \n\n\nSubmit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "Thank you for considering and taking the time to contribute!  The following are guidelines for contributing to this project.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#code-of-conduct", 
            "text": "This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the  Mozilla Community Participation Guidelines  and  Developer Etiquette Guidelines .", 
            "title": "Code of Conduct"
        }, 
        {
            "location": "/contributing/#how-to-get-started", 
            "text": "Please refer to installation and build instructions in the  documentation .", 
            "title": "How to Get Started"
        }, 
        {
            "location": "/contributing/#how-to-report-bugs", 
            "text": "Please open  a new issue in the GitHub repository  with steps to reproduce the problem you're experiencing.  Be sure to include as much information including screenshots, text output, and both your expected and actual results.", 
            "title": "How to Report Bugs"
        }, 
        {
            "location": "/contributing/#how-to-request-enhancements", 
            "text": "First, please refer to the applicable  GitHub repository  and search  the repository's GitHub issues  to make sure your idea has not been (or is not still) considered.  Then, please  create a new issue in the GitHub repository  describing your enhancement.  Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile.  Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.", 
            "title": "How to Request Enhancements"
        }, 
        {
            "location": "/contributing/#how-to-contribute-code", 
            "text": "Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of  good first issues  and find something that sounds interesting.  If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to  file an issue  first.  Once you have a patch ready:   Make sure all tests are passing and try to add tests for the code you've written.   Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.", 
            "title": "How to Contribute Code"
        }, 
        {
            "location": "/architecture/sec-apis/", 
            "text": "On Using Keys and Biometrics\n\n\nBelow are some findings on using a couple of security features in Android:\n\n\n\n\nAndroidKeyStore\n\n\nBiometrics\n\n\nDevice locks\n\n\n\n\nUsing \nAndroidKeyStore\n\n\nThe \nAndroidKeyStore\n is an implementation of the \nJava Cryptography Architecture (JCA)\n's \nKeyStore\n service to manage application-specific cryptographic keys.  Such keys can be created or imported with an associated label, then an opaque \nKey\n class obtained from that label to use for cryptographic operations.  However, they \ncannot\n be exported.  The remainder here focuses on creating rather than import.\n\n\nObtaining this Keystore is done using the static method \nKeystore.getIstance()\n and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider.\n\n\nNew keys are created using an instance of \nKeyGenerator\n (or \nKeyPairGenerator\n), again specifying \"AndroidKeyStore\" as the SPI provider.  When creating a new key, several properties can be applied via \nKeyGenParameterSpec\n, including:\n\n\n\n\nkey size (in bits)\n\n\nencryption block modes (e.g., \nGCM\n)\n\n\nencryption padding (e.g., \nNONE\n) \n\n\nrequire authentication\n\n\nduration until next authentication (in seconds)\n\n\n\n\nOnce set, these properties \ncannot\n be changed without first deleting then re-importing/-creating the key.  If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for \nevery\n use, it can only be done if the user has at least one fingerprint enrolled.\n\n\nKeys in the AndroidKeyStore are stored on the device until one of the following happens:\n\n\n\n\nThe app deletes its entry from the KeyStore\n\n\nThe app's data storage (not data cache) is cleared\n\n\nThe app is uninstalled\n\n\n\n\nKeys with user authentication required are invalided and cannot be used if any of the following happen:\n\n\n\n\nThe device is hard reset\n\n\nThe security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None)\n\n\n\n\nFurther, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen:\n\n\n\n\nA new fingerprint is enrolled\n\n\nAll fingerprints are unenrolled\n\n\n\n\nExisting Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., \n.getSecretKey()\n).  Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return \nnull\n; this is true even for PublicKeys.\n\n\nthe \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment.  If the key requires authentication, a \nUserNotAuthenticatedException\n is thrown; if the key no longer valid (as above), a \nKeyPermanentlyInvalidatedException\n is thrown.\n\n\nUsing KeyguardManager\n\n\nThe KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device.  It can only be obtained from a \nContext\n (e.g., \nActivity\n).\n\n\nThe most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked.  Both are boolean values; it is not possible to determine \nwhich\n method of lock is configured.\n\n\nIn addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of \ncreateConfirmDeviceCredentialIntent()\n; if no \"strong\" security lock is configured, this method returns \nnull\n.\n\n\nThe Intent is created with optional title and description, then dispatched via \nstartActivityForResult()\n to trigger the device prompts.  Applications receive either \nRESULT_OK\n (if successfully unlocked) or \nRESULT_CANCELED\n (device prompt is dismissed) via the overridden method \nonActivityResult()\n.  It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.\n\n\nUsing FingerprintManager\n\n\nNOTE:\n This API is marked as \ndeprecated\n as of API 28 (Android Pie) and replaced with \nBiometricPrompt\n.\n\n\nThe FingerprintManager is a system service used to interact with a device's fingerprint hardware.  This was added in API 23, and is now deprecated as of API 28.  As with \nKeyguardManager\n it can only be obtained from a \nContext\n (e.g., \nActivity\n).  It also requires the \nUSE_FINGERPRINT\n or \nUSE_BIOMETRIC\n (added in API 28) permission in the app's manifest.\n\n\nThere are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled.\n\n\nEngaging the fingerprint reader is done by calling \nauthenticate()\n.  Before doing so, the app must provide a \nFingerprintManager.CryptoObject\n and a \nFingerprintManager.AuthenticationCallback\n.  This method returns immediately; further interaction happens via the passed-in \nAuthenticationCallback\n.  An optional \nCancellationSignal\n can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button).\n\n\nThis object only engages the hardware; it does not display anything to the user itself.  The app is responsible for managing a view regarding the fingerprint reading operations.\n\n\nOnce the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.\n\n\nAbout the CryptoObject\n\n\nThe required \nCryptoObject\n wraps a \nCipher\n, \nMac\n or \nSignature\n object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.\n\n\nAbout the AuthenticationCallback\n\n\nThe required \nAuthenticationCallback\n is where events from fingerprint reader attempts are dispatched.  Subclasses need only override the event methods they are interested in.\n\n\nOn success \nonAuthenticationSuccessful()\n is called with the original \nCryptoObject\n wrapped in a \nAuthenticationResult\n.  If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use).\n\n\nA fingerprint read failure is notified via \nonAuthenticaitonFailed()\n, such as a unrecognized print.  If there is some other temporary failure (e.g., dirty reader), \nonAuthenticationHelp()\n is called with the relevant status code and a (device locale appropriate) user-directed help message.\n\n\nPermanent errors are notified via \nonAuthenticationError()\n, with the relevant status code and (device locale appropriate) user-directed error message.\n\n\nUsing BiometricPrompt\n\n\nThe BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog.  This class is introduced in API 28 to replace FingerprintManager.  The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader).\n\n\nTo create a \nBiometricPrmpt\n, a \nBiometricPrompt.Builder\n is created (with an appropriate \nContext\n) and configured.  The app can set a title, subtitle, description, and \"cancel\" button behavior.  Once created, the app calls \nauthenticate()\n (just like with \nFingerprintManager\n).\n\n\nThe hardware-engagement behavior is nearly identical to \nFingerprintManager\n; the app is notified of events via an instance of \nBiometricPrompt.AuthenticationCallback\n (which has the exact same methods as \nFingerprintManager.AuthenticationCallback\n), can be canceled via a \nCancellationSignal\n, and operates on a \nCryptoObject\n.  The biggest differences are:\n\n\n\n\nThe \nCryptoObject\n is optional\n\n\nThe app must explicitly provide an \nExecutor\n where events are dispatched (this can be \nContext.mainExecutor\n)\n\n\nThe app no longer manages any view to interact with the user.", 
            "title": "Using Keys and Biometrics"
        }, 
        {
            "location": "/architecture/sec-apis/#on-using-keys-and-biometrics", 
            "text": "Below are some findings on using a couple of security features in Android:   AndroidKeyStore  Biometrics  Device locks", 
            "title": "On Using Keys and Biometrics"
        }, 
        {
            "location": "/architecture/sec-apis/#using-androidkeystore", 
            "text": "The  AndroidKeyStore  is an implementation of the  Java Cryptography Architecture (JCA) 's  KeyStore  service to manage application-specific cryptographic keys.  Such keys can be created or imported with an associated label, then an opaque  Key  class obtained from that label to use for cryptographic operations.  However, they  cannot  be exported.  The remainder here focuses on creating rather than import.  Obtaining this Keystore is done using the static method  Keystore.getIstance()  and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider.  New keys are created using an instance of  KeyGenerator  (or  KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider.  When creating a new key, several properties can be applied via  KeyGenParameterSpec , including:   key size (in bits)  encryption block modes (e.g.,  GCM )  encryption padding (e.g.,  NONE )   require authentication  duration until next authentication (in seconds)   Once set, these properties  cannot  be changed without first deleting then re-importing/-creating the key.  If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for  every  use, it can only be done if the user has at least one fingerprint enrolled.  Keys in the AndroidKeyStore are stored on the device until one of the following happens:   The app deletes its entry from the KeyStore  The app's data storage (not data cache) is cleared  The app is uninstalled   Keys with user authentication required are invalided and cannot be used if any of the following happen:   The device is hard reset  The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None)   Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen:   A new fingerprint is enrolled  All fingerprints are unenrolled   Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g.,  .getSecretKey() ).  Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return  null ; this is true even for PublicKeys.  the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment.  If the key requires authentication, a  UserNotAuthenticatedException  is thrown; if the key no longer valid (as above), a  KeyPermanentlyInvalidatedException  is thrown.", 
            "title": "Using AndroidKeyStore"
        }, 
        {
            "location": "/architecture/sec-apis/#using-keyguardmanager", 
            "text": "The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device.  It can only be obtained from a  Context  (e.g.,  Activity ).  The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked.  Both are boolean values; it is not possible to determine  which  method of lock is configured.  In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of  createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns  null .  The Intent is created with optional title and description, then dispatched via  startActivityForResult()  to trigger the device prompts.  Applications receive either  RESULT_OK  (if successfully unlocked) or  RESULT_CANCELED  (device prompt is dismissed) via the overridden method  onActivityResult() .  It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.", 
            "title": "Using KeyguardManager"
        }, 
        {
            "location": "/architecture/sec-apis/#using-fingerprintmanager", 
            "text": "NOTE:  This API is marked as  deprecated  as of API 28 (Android Pie) and replaced with  BiometricPrompt .  The FingerprintManager is a system service used to interact with a device's fingerprint hardware.  This was added in API 23, and is now deprecated as of API 28.  As with  KeyguardManager  it can only be obtained from a  Context  (e.g.,  Activity ).  It also requires the  USE_FINGERPRINT  or  USE_BIOMETRIC  (added in API 28) permission in the app's manifest.  There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled.  Engaging the fingerprint reader is done by calling  authenticate() .  Before doing so, the app must provide a  FingerprintManager.CryptoObject  and a  FingerprintManager.AuthenticationCallback .  This method returns immediately; further interaction happens via the passed-in  AuthenticationCallback .  An optional  CancellationSignal  can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button).  This object only engages the hardware; it does not display anything to the user itself.  The app is responsible for managing a view regarding the fingerprint reading operations.  Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.", 
            "title": "Using FingerprintManager"
        }, 
        {
            "location": "/architecture/sec-apis/#about-the-cryptoobject", 
            "text": "The required  CryptoObject  wraps a  Cipher ,  Mac  or  Signature  object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.", 
            "title": "About the CryptoObject"
        }, 
        {
            "location": "/architecture/sec-apis/#about-the-authenticationcallback", 
            "text": "The required  AuthenticationCallback  is where events from fingerprint reader attempts are dispatched.  Subclasses need only override the event methods they are interested in.  On success  onAuthenticationSuccessful()  is called with the original  CryptoObject  wrapped in a  AuthenticationResult .  If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use).  A fingerprint read failure is notified via  onAuthenticaitonFailed() , such as a unrecognized print.  If there is some other temporary failure (e.g., dirty reader),  onAuthenticationHelp()  is called with the relevant status code and a (device locale appropriate) user-directed help message.  Permanent errors are notified via  onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message.", 
            "title": "About the AuthenticationCallback"
        }, 
        {
            "location": "/architecture/sec-apis/#using-biometricprompt", 
            "text": "The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog.  This class is introduced in API 28 to replace FingerprintManager.  The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader).  To create a  BiometricPrmpt , a  BiometricPrompt.Builder  is created (with an appropriate  Context ) and configured.  The app can set a title, subtitle, description, and \"cancel\" button behavior.  Once created, the app calls  authenticate()  (just like with  FingerprintManager ).  The hardware-engagement behavior is nearly identical to  FingerprintManager ; the app is notified of events via an instance of  BiometricPrompt.AuthenticationCallback  (which has the exact same methods as  FingerprintManager.AuthenticationCallback ), can be canceled via a  CancellationSignal , and operates on a  CryptoObject .  The biggest differences are:   The  CryptoObject  is optional  The app must explicitly provide an  Executor  where events are dispatched (this can be  Context.mainExecutor )  The app no longer manages any view to interact with the user.", 
            "title": "Using BiometricPrompt"
        }, 
        {
            "location": "/install/", 
            "text": "Install the latest Android Studio\n\n\n\n\n\n\nClone the repository\n\n\n\n\n\n\nOpen the project in Android Studio\n\n\n\n\n\n\nBuild/Run the project", 
            "title": "Build and Install"
        }
    ]
}